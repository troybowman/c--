#include <common.h>
#include <asm.h>

#define MAXNAMELEN 32
#define EXIT "__exit"

//-----------------------------------------------------------------------------
static const char *tempreg_names[TEMPREGQTY] =
  { "$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6" };

static const char *svreg_names[SVREGQTY] =
  { "$s0", "$s1", "$s2", "$s3", "$s4", "$s5", "$s6", "$s7" };

static const char *argreg_names[ARGREGQTY] =
  { "$a0", "$a1", "$a2", "$a3" };

//-----------------------------------------------------------------------------
static bool prepare_named_symbol(asm_ctx_t &ctx, symref_t sym, const char *fmt, ...)
{
  // 'main' must remain as is - i.e. no autogenerated name
  if ( !sym->is_main() )
  {
    va_list va;
    va_start(va, fmt);

    // TODO: must get rid of this limitation
    char buf[MAXNAMELEN];
    vsnprintf(buf, MAXNAMELEN, fmt, va);

    va_end(va);

    sym->set_name(buf);
    if ( ctx.gsyms.get(sym->name()) != NULL )
      return false;
  }

  sym->loc.set_global();
  ctx.gsyms.insert(sym);

  return true;
}

//-----------------------------------------------------------------------------
template<class T> static void gen_asm_names(
    asm_ctx_t &ctx,
    T &syms,
    const char *pfx,
    bool make_dummy_names = false)
{
  size_t counter = 0;
  for ( typename T::iterator i = syms.begin(); i != syms.end(); i++ )
  {
    symref_t sym = *i;
    if ( make_dummy_names )
    {
      while ( !prepare_named_symbol(ctx, sym, "%s%lu", pfx, counter) )
        counter++;
    }
    else
    {
      prepare_named_symbol(ctx, sym, "%s%s", pfx, sym->c_str());
    }
  }
}

//-----------------------------------------------------------------------------
static void init_gsyms(asm_ctx_t &ctx, ir_t &ir)
{
  gen_asm_names<symtab_t>(ctx, ir.gsyms,   "_");
  gen_asm_names<strtab_t>(ctx, ir.strings, "_str", true);
  gen_asm_names<symvec_t>(ctx, ir.labels,  "_L",   true);

  ir.gsyms.clear();
  ir.strings.clear();
  ir.labels.clear();
}

//-----------------------------------------------------------------------------
static void gen_data_section(asm_ctx_t &ctx)
{
  ctx.out("\n.data\n\n");

  for ( symtab_t::const_iterator i = ctx.gsyms.begin(); i != ctx.gsyms.end(); i++ )
  {
    const symbol_t &sym = **i;

    if ( sym.type() == ST_FUNCTION || sym.type() == ST_LABEL )
      continue;

    ctx.out(TAB1"%s:\n", sym.c_str());

    switch ( sym.type() )
    {
      case ST_PRIMITIVE:
        if ( sym.base() == PRIM_INT )
          ctx.out(TAB2".space %d\n", WORDSIZE);
        else
          ctx.out(TAB2".space 1\n"
                  TAB2".align 2\n");
        break;
      case ST_ARRAY:
        if ( sym.base() == PRIM_INT )
          ctx.out(TAB2".space %d\n", sym.size() * WORDSIZE);
        else
          ctx.out(TAB2".space %d\n"
                  TAB2".align 2\n",  sym.size());
        break;
      case ST_STRCON:
        ctx.out(  TAB2".asciiz %s\n"
                  TAB2".align 2\n",  sym.str());
        break;
      default:
        INTERR(1085);
    }

    ctx.out("\n");
  }
}

//-----------------------------------------------------------------------------
void frame_section_t::visit_items(
    asm_context_t &actx,
    frame_item_visitor_t &fiv,
    uint32_t flags) const
{
  for ( size_t i = 0; i < items.size(); i++ )
  {
    size_t idx = (flags & FIV_REVERSE) == 0 ? i : items.size() - 1 - i;
    item_info_t info(actx, *this, idx);
    symbol_t &item = *items[idx];

    fiv.visit_item(info, item);
  }
}

//-----------------------------------------------------------------------------
void frame_section_t::visit_items(
    asm_context_t &actx,
    frame_item_builder_t &fib)
{
  for ( size_t i = 0; i < items.size(); i++ )
  {
    frame_mods_t mods(actx, *this, i);
    symbol_t &item = *items[i];

    fib.visit_item(mods, item);

    if ( info.delta != BADOFFSET )
      end += info.delta;
  }
}

//-----------------------------------------------------------------------------
static void build_regargs_section(
    asm_context_t &actx,
    stack_frame_t &frame,
    const ir_func_t &f)
{
  frame_section_t &regargs = frame.sections[FS_REGARGS];

  regargs.init(*f.get(ST_REGARG));

  if ( f.has_call() )
    regargs.end = ARGREGQTY * WORDSIZE;

  struct regargs_builder_t : public frame_item_builder_t
  {
    virtual void visit_item(frame_mods_t &, symbol_t &arg)
    {
      arg.loc.set_reg(argreg_names[arg.val()]);
    }
  } b;

  regargs.visit_items(actx, b);
}

//-----------------------------------------------------------------------------
static void build_stkargs_section(asm_context_t &actx, stack_frame_t &frame)
{
  frame_section_t &stkargs = frame.sections[FS_STKARGS];

  stkargs.init(*f.get(ST_STKARG));
  stkargs.start = stkargs.end = sections[FS_REGARGS].end;

  struct stkargs_builder_t : public frame_item_builder_t
  {
    virtual void visit_item(frame_mods_t &mods, symbol_t &stkarg)
    {
      stkarg.loc.set_stkoff(mods.sec.end);
      mods.delta = WORDSIZE;
    }
  } b;

  stkargs.visit_items(actx, b);
}

//-----------------------------------------------------------------------------
static void build_svregs_section(asm_context_t &actx, stack_frame_t &frame)
{
  frame_section_t &svregs = sections[FS_SVREGS];

  svregs.init(*f.get(ST_SVTEMP));
  svregs.start = svregs.end = sections[FS_STKARGS].end;

  struct svregs_builder_t : public frame_item_builder_t
  {
    virtual void visit_item(frame_mods_t &mods, symbol_t &svreg)
    {
      svreg.loc.set_reg(svreg_names[svreg.val()]);
      mods.delta = WORDSIZE;
    }
  } b;

  svregs.visit_items(actx, b);
}

//-----------------------------------------------------------------------------
static void build_stktemps_section(asm_context_t &actx, stack_frame_t &frame)
{
  frame_section_t &stktemps = sections[FS_STKTEMPS];

  stktemps.init(*f.get(ST_STKTEMP));
  stktemps.start = stktemps.end = sections[FS_SVREGS].end;

  struct stktemps_builder_t : public frame_item_builder_t
  {
    virtual void visit_item(frame_mods_t &info, symbol_t &mods)
    {
      stktemp.loc.set_stkoff(mods.sec.end);
      mods.delta = WORDSIZE;
    }
  } b;

  stktemps.visit_items(actx, b);
};

//-----------------------------------------------------------------------------
static void build_ra_section(asm_context_t &actx, stack_frame_t &frame)
{
  frame_section_t &ra = sections[FS_RA];

  ra.init(*f.get(ST_RETADDR));
  ra.start = ra.end = sections[FS_STKTEMPS].end;

  struct ra_builder_t : public frame_item_builder_t
  {
    virtual void visit_item(frame_mods_t &mods, symbol_t &ra)
    {
      ra.loc.set_reg("$ra");
      mods.delta = WORDSIZE;
    }
  } b;

  ra.visit_items(actx, b);
}

//-----------------------------------------------------------------------------
static void build_padding_section(
    stack_frame_t &frame,
    int padid,
    int previd)
{
  frame_section_t &padding = frame.sections[padid];

  padding.start = frame.sections[previd].end;
  padding.end   = ALIGN(padding.start, DWORDSIZE);
}

//-----------------------------------------------------------------------------
static void build_lvars_section(asm_context_t &actx, frame_section_t &frame)
{
  frame_section_t &lvars = frame.sections[FS_LVARS];

  lvars.init(*f.sym()->lvars());
  lvars.start = lvars.end = sections[FS_PADDING1].end;

  struct lvars_builder_t : public frame_item_visitor_t
  {
    virtual void visit_item(frame_mods_t &mods, symbol_t &lvar)
    {
      if ( lvar.is_param() )
        return;

      lvar.loc.set_stkoff(mods.sec.end);
      mods.delta = ALIGN(lvar.size(), WORDSIZE);
    }
  } b;

  lvars.visit_items(actx, b);
}

//-----------------------------------------------------------------------------
static void build_params_section(asm_context_t &actx, stack_frame_t &frame)
{
  frame_section_t &params = frame.sections[FS_PARAMS];

  params.init(*f.sym()->params());
  params.start = params.end = sections[FS_PADDING2].end;

  struct params_builder_t : public frame_item_builder_t
  {
    uint32_t nregargs;

    virtual void visit_item(frame_mods_t &mods, symbol_t &param)
    {
      if ( mods.idx < ARGREGQTY && mods.idx >= nregargs )
        param.loc.set_reg(argreg_names[mods.idx]);
      else
        param.loc.set_stkoff(mods.sec.end);

      mods.delta = WORDISZE;
    }

    params_builder_t(uint32_t _nregargs) : nregargs(_nregargs) {}

  } b(sections[FS_REGARGS].nitems());

  params.visit_items(actx, b);
}

//-----------------------------------------------------------------------------
stack_frame_t::stack_frame_t(asm_ctx_t &actx, const ir_func_t &f)
{
  epilogue_label = symref_t(new symbol_t(ST_LABEL));
  prepare_named_symbol(ctx, epilogue_label, "%s%s", "__leave", f.sym()->c_str());

  build_regargs_section(actx, *this, f);
  build_stkargs_section(actx, *this);
  build_svregs_section(actx, *this);
  build_stktemps_section(actx, *this);
  build_ra_section(actx, *this);
  build_padding_section(*this, FS_PADDING1, FS_RA);
  build_lvars_section(actx, *this);
  build_padding_section(*this, FS_PADDING2, FS_LVARS);
  build_params_section(actx, *this);
}

//-----------------------------------------------------------------------------
struct reg_saver_t : public frame_item_visitor_t
{
  const char *cmd;
  frame_section_t &base;

  virtual void visit_item(item_info_t &info, const symbol_t &sym)
  {
    info.actx.out(TAB1,
        "%s %s, %d($sp)\n",
        cmd,
        sym.loc.reg(),
        base.start + info.idx * WORDSIZE);
  }

  reg_saver_t(const char *_cmd, frame_section_t &_base) : cmd(_cmd), base(_base) {}
};

//-----------------------------------------------------------------------------
static const struct saver_pair_t { int sec; int base; } pairs[3] =
{
 { FS_SVREGS,  FS_SVREGS },
 { FS_RA,      FS_RA     },
 { FS_REGARGS, FS_PARAMS },
};

//-----------------------------------------------------------------------------
void stack_frame_t::gen_prologue()
{
  if ( size() > 0 )
    ctx.out(TAB1"la $sp, -%u($sp)\n", size());

  for ( int i = 0; i < 3; i++ )
  {
    reg_saver_t saver("sw", sections[pairs[i].base]);
    visit_items(pairs[i].sec, saver);
  }

  ctx.out("\n");
}

//-----------------------------------------------------------------------------
void stack_frame_t::gen_epilogue()
{
  ctx.out("\n%s:\n", epilogue_label->c_str());

  for ( int i = 2; i >= 0; i-- )
  {
    reg_saver_t saver("lw", sections[pairs[i].base]);
    visit_items(pairs[i].sec, saver, FIV_REVERSE);
  }

  if ( size() > 0 )
    ctx.out(TAB1"la $sp, %u($sp)\n", size());

  // MARS, for some utterly moronic reason, does not call main. we must manually exit
  if ( f.sym()->is_main() )
    ctx.out(TAB1"jal %s\n", EXIT);
  else
    ctx.out(TAB1"jr $ra\n");
}

//-----------------------------------------------------------------------------
#define REQUIRE_REG_DEST 0x1
#define REQUIRE_REG_SRC1 0x2
#define REQUIRE_REG_SRC2 0x4

//-----------------------------------------------------------------------------
static void ensure_compatible_operands(asm_ctx_t &ctx, codenode_t *node, uint32_t flags)
{
  symref_t dest = node->dest;
  symref_t src1 = node->src1;
  symref_t src2 = node->src2;

  if ( (flags & REQUIRE_REG_SRC1) != 0 && !src1->loc.is_reg() )
  {
    if ( src1->loc.is_stkoff() )
      ctx.out(TAB1"lw %s, %d($sp)\n", ctx.t7->loc.reg(), src1->loc.stkoff());
    else
      ctx.out(TAB1"lw %s, %s\n", ctx.t7->loc.reg(), src1->c_str());

    node->src1 = ctx.t7;
  }

  if ( (flags & REQUIRE_REG_SRC2) != 0 && !src2->loc.is_reg() )
  {
    if ( src2->loc.is_stkoff() )
      ctx.out(TAB1"lw %s, %d($sp)\n", ctx.t8->loc.reg(), src2->loc.stkoff());
    else
      ctx.out(TAB1"lw %s, %s\n", ctx.t8->loc.reg(), src2->c_str());

    node->src2 = ctx.t8;
  }

  if ( (flags & REQUIRE_REG_DEST) != 0 && !dest->loc.is_reg() )
  {
    symref_t olddest = node->dest;
    node->dest = ctx.t9;
    codenode_t *store = new codenode_t(CNT_SW, olddest, ctx.t9, NULLREF);
    codenode_t *oldnext = node->next;
    node->next = store;
    store->next = oldnext;
  }
}

//-----------------------------------------------------------------------------
static const char *cnt2instr(codenode_type_t type)
{
  switch ( type )
  {
    case CNT_ADD:  return "addu";
    case CNT_SUB:  return "sub";
    case CNT_DIV:  return "div";
    case CNT_MUL:  return "mul";
    case CNT_AND:  return "and";
    case CNT_OR:   return "or";
    case CNT_SLT:  return "slt";
    case CNT_SGT:  return "sgt";
    case CNT_SLE:  return "sle";
    case CNT_SEQ:  return "seq";
    case CNT_SNE:  return "sne";
    case CNT_SGE:  return "sge";
    case CNT_XOR:  return "xor";
    case CNT_SLLV: return "sllv";
    case CNT_SRLV: return "srlv";
    default:
      INTERR(1089);
  }
}

//-----------------------------------------------------------------------------
static uint32_t get_operand_desc(codenode_type_t type)
{
  switch ( type )
  {
    case CNT_LI:
    case CNT_LEA:
    case CNT_LB:
    case CNT_LW:
      return REQUIRE_REG_DEST;
    case CNT_MOV:
    case CNT_SB:
    case CNT_SW:
    case CNT_CNDJMP:
      return REQUIRE_REG_SRC1;
    case CNT_ADD:
    case CNT_SUB:
    case CNT_DIV:
    case CNT_MUL:
    case CNT_AND:
    case CNT_OR:
    case CNT_SLT:
    case CNT_SGT:
    case CNT_SLE:
    case CNT_SEQ:
    case CNT_SNE:
    case CNT_SGE:
    case CNT_SLLV:
    case CNT_SRLV:
      return REQUIRE_REG_DEST | REQUIRE_REG_SRC1 | REQUIRE_REG_SRC2;
    case CNT_SLL:
    case CNT_XOR:
    case CNT_NOT:
      return REQUIRE_REG_DEST | REQUIRE_REG_SRC1;
    default:
      break;
  }
  return 0;
}

//-----------------------------------------------------------------------------
static void gen_func_body(asm_ctx_t &ctx, codenode_t *code, symref_t epilogue)
{
  for ( code_iterator_t ci(code); *ci != NULL; ci++ )
  {
    codenode_t *node = *ci;

    ensure_compatible_operands(ctx, node, get_operand_desc(node->type));

    symref_t dest = node->dest;
    symref_t src1 = node->src1;
    symref_t src2 = node->src2;

    switch ( node->type )
    {
      case CNT_LI:
        {
          switch ( src1->type() )
          {
            case ST_INTCON:
              ctx.out(TAB1"li %s, %d\n", dest->loc.reg(), src1->val());
              break;
            case ST_CHARCON:
              ctx.out(TAB1"li %s, %s\n", dest->loc.reg(), src1->str());
              break;
            default:
              INTERR(1090);
          }
        }
        break;
      case CNT_MOV:
        {
          switch ( dest->loc.type() )
          {
            case SLT_GLOBAL:
              ctx.out(TAB1"sw %s, %s\n", src1->loc.reg(), dest->c_str());
              break;
            case SLT_STKOFF:
              ctx.out(TAB1"sw %s, %d($sp)\n", src1->loc.reg(), dest->loc.stkoff());
              break;
            case SLT_REG:
              ctx.out(TAB1"move %s, %s\n", dest->loc.reg(), src1->loc.reg());
              break;
            default:
              INTERR(1091);
          }
        }
        break;
      case CNT_LEA:
        {
          switch ( src1->loc.type() )
          {
            case SLT_GLOBAL:
              ctx.out(TAB1"la %s, %s\n", dest->loc.reg(), src1->c_str());
              break;
            case SLT_STKOFF:
              if ( src1->is_param() )
                ctx.out(TAB1"lw %s, %d($sp)\n", dest->loc.reg(), src1->loc.stkoff());
              else
                ctx.out(TAB1"la %s, %d($sp)\n", dest->loc.reg(), src1->loc.stkoff());
              break;
            case SLT_REG:
              ctx.out(TAB1"move %s, %s\n", dest->loc.reg(), src1->loc.reg());
              break;
            default:
              INTERR(1092);
          }
        }
        break;
      case CNT_SB:
      case CNT_SW:
        {
          const char *store = node->type == CNT_SB ? "sb" : "sw";

          switch ( dest->loc.type() )
          {
            case SLT_GLOBAL:
              ctx.out(TAB1"%s %s, %s\n", store, src1->loc.reg(), dest->c_str());
              break;
            case SLT_STKOFF:
              ctx.out(TAB1"%s %s, %d($sp)\n", store, src1->loc.reg(), dest->loc.stkoff());
              break;
            case SLT_REG:
              if ( dest->is_param() )
                ctx.out(TAB1"move %s, %s\n", dest->loc.reg(), src1->loc.reg());
              else
                ctx.out(TAB1"%s %s, (%s)\n", store, src1->loc.reg(), dest->loc.reg());
              break;
            default:
              INTERR(1093);
          }
        }
        break;
      case CNT_LB:
      case CNT_LW:
        {
          const char *load = node->type == CNT_LB ? "lb" : "lw";

          switch ( src1->loc.type() )
          {
            case SLT_GLOBAL:
              ctx.out(TAB1"%s %s, %s\n", load, dest->loc.reg(), src1->c_str());
              break;
            case SLT_STKOFF:
              ctx.out(TAB1"%s %s, %d($sp)\n", load, dest->loc.reg(), src1->loc.stkoff());
              break;
            case SLT_REG:
              if ( src1->is_param() )
                ctx.out(TAB1"move %s, %s\n", dest->loc.reg(), src1->loc.reg());
              else
                ctx.out(TAB1"%s %s, (%s)\n", load, dest->loc.reg(), src1->loc.reg());
              break;
            default:
              INTERR(1094);
          }
        }
        break;
      case CNT_ARG:
        {
          switch ( dest->loc.type() )
          {
            case SLT_REG:
              {
                switch ( src1->loc.type() )
                {
                  case SLT_STKOFF:
                    ctx.out(TAB1"lw %s, %d($sp)\n", dest->loc.reg(), src1->loc.stkoff());
                    break;
                  case SLT_REG:
                    ctx.out(TAB1"move %s, %s\n", dest->loc.reg(), src1->loc.reg());
                    break;
                  default:
                    INTERR(1095);
                }
              }
              break;
            case SLT_STKOFF:
              {
                switch ( src1->loc.type() )
                {
                  case SLT_STKOFF:
                    ensure_compatible_operands(ctx, node, REQUIRE_REG_SRC1);
                    src1 = node->src1;
                  case SLT_REG:
                    ctx.out(TAB1"sw %s, %d($sp)\n", src1->loc.reg(), dest->loc.stkoff());
                    break;
                  default:
                    INTERR(1096);
                }
              }
              break;
            default:
              INTERR(1097);
          }
        }
        break;
      case CNT_RET:
        {
          if ( dest != NULL )
          {
            switch ( src1->loc.type() )
            {
              case SLT_GLOBAL:
                ctx.out(TAB1"lw %s, %s\n", dest->loc.reg(), src1->c_str());
                break;
              case SLT_STKOFF:
                ctx.out(TAB1"lw %s, %d($sp)\n", dest->loc.reg(), src1->loc.stkoff());
                break;
              case SLT_REG:
                ctx.out(TAB1"move %s, %s\n", dest->loc.reg(), src1->loc.reg());
                break;
              default:
                INTERR(1098);
            }
          }

          ctx.out(TAB1"j %s\n", epilogue->c_str());
        }
        break;
      case CNT_SLL:
      case CNT_XOR:
        {
          const char *instr = node->type == CNT_SLL ? "sll" : "xor";

          switch ( src2->type() )
          {
            case ST_INTCON:
              ctx.out(TAB1"%s %s, %s, %d\n",
                      instr, dest->loc.reg(), src1->loc.reg(), src2->val());
              break;
            case ST_TEMP:
              ASSERT(0, node->type != CNT_SLL);
              ctx.out(TAB1"%s %s, %s, %s\n",
                      instr, dest->loc.reg(), src1->loc.reg(), src2->loc.reg());
              break;
            default:
              INTERR(0);
          }
        }
        break;
      case CNT_ADD:
      case CNT_SUB:
      case CNT_DIV:
      case CNT_MUL:
      case CNT_AND:
      case CNT_OR:
      case CNT_SLT:
      case CNT_SGT:
      case CNT_SLE:
      case CNT_SEQ:
      case CNT_SNE:
      case CNT_SGE:
      case CNT_SLLV:
      case CNT_SRLV:
        ctx.out(TAB1"%s %s, %s, %s\n",
                cnt2instr(node->type), dest->loc.reg(), src1->loc.reg(), src2->loc.reg());
        break;
      case CNT_CNDJMP:
        ctx.out(TAB1"beq %s, $zero, %s\n", src1->loc.reg(), dest->c_str());
        break;
      case CNT_NOT:
        ctx.out(TAB1"not %s, %s\n", dest->loc.reg(), src1->loc.reg());
        break;
      case CNT_CALL:
        ctx.out(TAB1"jal %s\n", node->src1->c_str());
        break;
      case CNT_LABEL:
        ctx.out("%s:\n", node->src1->c_str());
        break;
      case CNT_JUMP:
        ctx.out(TAB1"j %s\n", node->dest->c_str());
        break;
      default:
        continue;
    }
  }
}

//-----------------------------------------------------------------------------
static void gen_builtin_function(asm_ctx_t &ctx, const char *name, int syscall)
{
  ctx.out("\n%s:\n"
          TAB1"li $v0, %d\n"
          TAB1"syscall\n"
          TAB1"jr $ra\n", name, syscall);
}

//-----------------------------------------------------------------------------
static void init_resources(ir_func_t &f)
{
  symvec_t temps;
  f.get_used_resources(ST_TEMP, temps);

  for ( symvec_t::iterator i = temps.begin(); i != temps.end(); i++ )
  {
    symbol_t &temp = **i;
    temp.loc.set_reg(tempreg_names[temp.val()]);
  }

  symref_t retval = f.gen_resource(ST_RETVAL);
  retval->loc.set_reg("$v0");

  symref_t zero = f.gen_resource(ST_ZERO);
  zero->loc.set_reg("$zero");
}

//-----------------------------------------------------------------------------
static void gen_text_section(asm_ctx_t &ctx, ir_funcs_t &funcs)
{
  ctx.out(".text\n");

  for ( ir_funcs_t::iterator i = funcs.begin(); i != funcs.end(); i++ )
  {
    ir_func_t &f = **i;
    init_resources(f);

    ctx.out("\n%s:\n", f.sym()->c_str());

    stack_frame_t frame(f, ctx);
    LOG_FRAME_SUMMARY(frame);

    frame.gen_prologue();
    gen_func_body(ctx, f.code(), frame.epilogue_lbl);
    frame.gen_epilogue();
  }

  gen_builtin_function(ctx, "_"BI_PRINT_STRING, 4);
  gen_builtin_function(ctx, "_"BI_PRINT_INT,    1);
  gen_builtin_function(ctx, "_"BI_PRINT_CHAR,  11);
  gen_builtin_function(ctx, "_"BI_PRINT_HEX,   34);
  gen_builtin_function(ctx, EXIT, 10);
}

//-----------------------------------------------------------------------------
void generate_mips_asm(asm_ctx_t &ctx, ir_t &ir)
{
  init_gsyms(ctx, ir);
  gen_data_section(ctx);
  gen_text_section(ctx, ir.funcs);
}
