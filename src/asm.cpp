#include <common.h>
#include <asm.h>

#define MAXNAMELEN 32
#define EXIT "__exit"

//-----------------------------------------------------------------------------
static const char *tempreg_names[TEMPREGQTY] =
  { "$t0", "$t1", "$t2", "$t3", "$t4", "$t5", "$t6" };

static const char *svreg_names[SVREGQTY] =
  { "$s0", "$s1", "$s2", "$s3", "$s4", "$s5", "$s6", "$s7" };

static const char *argreg_names[ARGREGQTY] =
  { "$a0", "$a1", "$a2", "$a3" };

#define RESERVED_TEMP1 "$t7"
#define RESERVED_TEMP2 "$t8"
#define RESERVED_TEMP3 "$t9"

//-----------------------------------------------------------------------------
asm_ctx_t::asm_ctx_t(FILE *_outfile) :
    outfile(_outfile),
    t7(new symbol_t(ST_TEMP)),
    t8(new symbol_t(ST_TEMP)),
    t9(new symbol_t(ST_TEMP))
{
  t7->loc.set_reg(RESERVED_TEMP1);
  t8->loc.set_reg(RESERVED_TEMP2);
  t9->loc.set_reg(RESERVED_TEMP3);
}

//-----------------------------------------------------------------------------
void asm_ctx_t::out(const char *fmt, ...)
{
  va_list va;
  va_start(va, fmt);
  vfprintf(outfile, fmt, va);
  va_end(va);
}

//-----------------------------------------------------------------------------
static bool prepare_named_symbol(asm_ctx_t &ctx, symref_t sym, const char *fmt, ...)
{
  // 'main' must remain as is - i.e. no autogenerated name
  if ( !sym->is_main() )
  {
    va_list va;
    va_start(va, fmt);

    // TODO: must get rid of this limitation
    char buf[MAXNAMELEN];
    vsnprintf(buf, MAXNAMELEN, fmt, va);

    va_end(va);

    sym->set_name(buf);
    if ( ctx.gsyms.get(sym->name()) != NULL )
      return false;
  }

  sym->loc.set_global();
  ctx.gsyms.insert(sym);

  return true;
}

//-----------------------------------------------------------------------------
template<class T> static void gen_asm_names(
    asm_ctx_t &ctx,
    T &syms,
    const char *pfx,
    bool make_dummy_names = false)
{
  size_t counter = 0;
  for ( typename T::iterator i = syms.begin(); i != syms.end(); i++ )
  {
    symref_t sym = *i;
    if ( make_dummy_names )
    {
      while ( !prepare_named_symbol(ctx, sym, "%s%lu", pfx, counter) )
        counter++;
    }
    else
    {
      prepare_named_symbol(ctx, sym, "%s%s", pfx, sym->c_str());
    }
  }
}

//-----------------------------------------------------------------------------
static void init_gsyms(asm_ctx_t &ctx, ir_t &ir)
{
  gen_asm_names<symtab_t>(ctx, ir.gsyms,   "_");
  gen_asm_names<symtab_t>(ctx, ir.strings, "_str", true);
  gen_asm_names<symvec_t>(ctx, ir.labels,  "_L",   true);

  ir.gsyms.clear();
  ir.strings.clear();
  ir.labels.clear();
}

//-----------------------------------------------------------------------------
static void gen_data_section(asm_ctx_t &ctx)
{
  ctx.out("\n.data\n\n");

  for ( symtab_t::const_iterator i = ctx.gsyms.begin(); i != ctx.gsyms.end(); i++ )
  {
    const symbol_t &sym = **i;

    if ( sym.type() == ST_FUNCTION || sym.type() == ST_LABEL )
      continue;

    ctx.out(TAB1"%s:\n", sym.c_str());

    switch ( sym.type() )
    {
      case ST_PRIMITIVE:
        if ( sym.base() == PRIM_INT )
          ctx.out(TAB2".space %d\n", WORDSIZE);
        else
          ctx.out(TAB2".space 1\n"
                  TAB2".align 2\n");
        break;
      case ST_ARRAY:
        if ( sym.base() == PRIM_INT )
          ctx.out(TAB2".space %d\n", sym.size() * WORDSIZE);
        else
          ctx.out(TAB2".space %d\n"
                  TAB2".align 2\n",  sym.size());
        break;
      case ST_STRCON:
        ctx.out(  TAB2".asciiz %s\n"
                  TAB2".align 2\n",  sym.str());
        break;
      default:
        INTERR(1085);
    }

    ctx.out("\n");
  }
}

//-----------------------------------------------------------------------------
void frame_section_t::visit_items(
    stack_frame_t &frame,
    frame_item_visitor_t &fiv,
    uint32_t flags)
{
  for ( size_t i = 0; i < items.size(); i++ )
  {
    size_t idx = (flags & FIV_REVERSE) == 0 ? i : items.size() - 1 - i;
    item_info_t info(frame, *this, *items[idx], idx);
    fiv.visit_item(info);
  }
}

//-----------------------------------------------------------------------------
inline void stack_frame_t::visit_items(
    int sectionidx,
    frame_item_visitor_t &fiv,
    uint32_t flags)
{
  sections[sectionidx].visit_items(*this, fiv, flags);
}

//-----------------------------------------------------------------------------
void stack_frame_t::build_regargs_section()
{
  frame_section_t &regargs = sections[FS_REGARGS];

  regargs.init(*f.get(ST_REGARG));

  if ( f.has_call )
    regargs.end = ARGREGQTY * WORDSIZE;

  struct regargs_builder_t : public frame_item_visitor_t
  {
    virtual void visit_item(item_info_t &info)
    {
      symbol_t &regarg = info.sym;
      regarg.loc.set_reg(argreg_names[regarg.val()]);
    }
  } b;

  visit_items(FS_REGARGS, b);
}

//-----------------------------------------------------------------------------
void stack_frame_t::build_stkargs_section()
{
  frame_section_t &stkargs = sections[FS_STKARGS];

  stkargs.init(*f.get(ST_STKARG));
  stkargs.start = stkargs.end = sections[FS_REGARGS].end;

  struct stkargs_builder_t : public frame_item_visitor_t
  {
    virtual void visit_item(item_info_t &info)
    {
      info.sym.loc.set_stkoff(info.sec.end);
      info.sec.end += WORDSIZE;
    }
  } b;

  visit_items(FS_STKARGS, b);
}

//-----------------------------------------------------------------------------
void stack_frame_t::build_svregs_section()
{
  frame_section_t &svregs = sections[FS_SVREGS];

  svregs.init(*f.get(ST_SVTEMP));
  svregs.start = svregs.end = sections[FS_STKARGS].end;

  struct svregs_builder_t : public frame_item_visitor_t
  {
    virtual void visit_item(item_info_t &info)
    {
      symbol_t &svreg = info.sym;
      svreg.loc.set_reg(svreg_names[svreg.val()]);
      info.sec.end += WORDSIZE;
    }
  } b;

  visit_items(FS_SVREGS, b);
}

//-----------------------------------------------------------------------------
void stack_frame_t::build_stktemps_section()
{
  frame_section_t &stktemps = sections[FS_STKTEMPS];

  stktemps.init(*f.get(ST_STKTEMP));
  stktemps.start = stktemps.end = sections[FS_SVREGS].end;

  struct stktemps_builder_t : public frame_item_visitor_t
  {
    virtual void visit_item(item_info_t &info)
    {
      info.sym.loc.set_stkoff(info.sec.end);
      info.sec.end += WORDSIZE;
    }
  } b;

  visit_items(FS_STKTEMPS, b);
};

//-----------------------------------------------------------------------------
void stack_frame_t::build_ra_section()
{
  frame_section_t &ra = sections[FS_RA];

  ra.init(*f.get(ST_RETADDR));
  ra.start = ra.end = sections[FS_STKTEMPS].end;

  struct ra_builder_t : public frame_item_visitor_t
  {
    virtual void visit_item(item_info_t &info)
    {
      info.sym.loc.set_reg("$ra");
      info.sec.end += WORDSIZE;
    }
  } b;

  visit_items(FS_RA, b);
}

//-----------------------------------------------------------------------------
void stack_frame_t::build_padding_section(int padid, int previd)
{
  frame_section_t &padding = sections[padid];

  padding.start = sections[previd].end;
  padding.end   = ALIGN(padding.start, DWORDSIZE);
}

//-----------------------------------------------------------------------------
void stack_frame_t::build_lvars_section()
{
  frame_section_t &lvars = sections[FS_LVARS];

  lvars.init(*f.sym->symbols());
  lvars.start = lvars.end = sections[FS_PADDING1].end;

  struct lvars_builder_t : public frame_item_visitor_t
  {
    virtual void visit_item(item_info_t &info)
    {
      symbol_t &lvar = info.sym;
      frame_section_t &sec = info.sec;

      if ( lvar.is_param() )
        return;

      lvar.loc.set_stkoff(sec.end);

      switch ( lvar.type() )
      {
        case ST_PRIMITIVE:
          sec.end += lvar.base() == PRIM_INT ? WORDSIZE : 1;
          break;
        case ST_ARRAY:
          sec.end += lvar.base() == PRIM_INT
                   ? WORDSIZE * lvar.size()
                   : lvar.size();
          break;
        default:
          INTERR(1086);
      }

      sec.end = ALIGN(sec.end, WORDSIZE); // align to word boundary
    }
  } b;

  visit_items(FS_LVARS, b);
}

//-----------------------------------------------------------------------------
void stack_frame_t::build_params_section()
{
  frame_section_t &params = sections[FS_PARAMS];

  params.init(*f.sym->params());
  params.start = params.end = sections[FS_PADDING2].end;

  struct params_builder_t : public frame_item_visitor_t
  {
    uint32_t nregargs;

    virtual void visit_item(item_info_t &info)
    {
      symloc_t &loc = info.sym.loc;

      if ( info.idx < ARGREGQTY && info.idx >= nregargs )
        loc.set_reg(argreg_names[info.idx]);
      else
        loc.set_stkoff(info.sec.end);

      info.sec.end += WORDSIZE;
    }
  } b;

  b.nregargs = sections[FS_REGARGS].nitems();

  visit_items(FS_PARAMS, b);
}

//-----------------------------------------------------------------------------
stack_frame_t::stack_frame_t(const ir_func_t &_f, asm_ctx_t &_ctx)
  : f(_f), ctx(_ctx), epilogue_lbl(new symbol_t(ST_LABEL))
{
  prepare_named_symbol(ctx, epilogue_lbl, "%s%s", "__leave", f.sym->c_str());

  build_regargs_section();
  build_stkargs_section();
  build_svregs_section();
  build_stktemps_section();
  build_ra_section();
  build_padding_section(FS_PADDING1, FS_RA);
  build_lvars_section();
  build_padding_section(FS_PADDING2, FS_LVARS);
  build_params_section();
}

//-----------------------------------------------------------------------------
struct stack_frame_t::reg_saver_t : public frame_item_visitor_t
{
  const char *cmd;
  frame_section_t &base;

  virtual void visit_item(item_info_t &info)
  {
    info.frame.ctx.out(
        TAB1"%s %s, %d($sp)\n",
        cmd,
        info.sym.loc.reg(),
        base.start + info.idx * WORDSIZE);
  }

  reg_saver_t(const char *_cmd, frame_section_t &_base) : cmd(_cmd), base(_base) {}
};

//-----------------------------------------------------------------------------
static const struct saver_pair_t { int sec; int base; } pairs[3] =
{
 { FS_SVREGS,  FS_SVREGS },
 { FS_RA,      FS_RA     },
 { FS_REGARGS, FS_PARAMS },
};

//-----------------------------------------------------------------------------
void stack_frame_t::gen_prologue()
{
  if ( size() > 0 )
    ctx.out(TAB1"la $sp, -%u($sp)\n", size());

  for ( int i = 0; i < 3; i++ )
  {
    reg_saver_t saver("sw", sections[pairs[i].base]);
    visit_items(pairs[i].sec, saver);
  }

  ctx.out("\n");
}

//-----------------------------------------------------------------------------
void stack_frame_t::gen_epilogue()
{
  ctx.out("\n%s:\n", epilogue_lbl->c_str());

  for ( int i = 2; i >= 0; i-- )
  {
    reg_saver_t saver("lw", sections[pairs[i].base]);
    visit_items(pairs[i].sec, saver, FIV_REVERSE);
  }

  if ( size() > 0 )
    ctx.out(TAB1"la $sp, %u($sp)\n", size());

  // MARS, for some utterly moronic reason, does not call main. we must manually exit
  if ( f.sym->is_main() )
    ctx.out(TAB1"jal %s\n", EXIT);
  else
    ctx.out(TAB1"jr $ra\n");
}

//-----------------------------------------------------------------------------
#define REQUIRE_REG_DEST 0x1
#define REQUIRE_REG_SRC1 0x2
#define REQUIRE_REG_SRC2 0x4

#define REQUIRES_SWAP(flag, sym) ((flags & flag) != 0 && !sym->loc.is_reg())

//-----------------------------------------------------------------------------
static bool maybe_swap_source_operand(
    asm_ctx_t &ctx,
    uint32_t flags,
    uint32_t flag,
    codenode_t *node,
    symref_t swap_out,
    symref_t swap_in)
{
  if ( REQUIRES_SWAP(flag, swap_out) )
  {
    switch ( swap_out->loc.type() )
    {
      case SLT_STKOFF:
        ctx.out(TAB1"lw %s, %d($sp)\n", swap_in->loc.reg(), swap_out->loc.stkoff());
        break;
      case SLT_GLOBAL:
        ctx.out(TAB1"lw %s, %s\n", swap_in->loc.reg(), swap_out->c_str());
        break;
      default:
        INTERR(0); // registers should always be compatible
    }
    return true;
  }
  return false;
}

//-----------------------------------------------------------------------------
static void ensure_compatible_operands(asm_ctx_t &ctx, codenode_t *node, uint32_t flags)
{
  symref_t dest = node->dest;
  symref_t src1 = node->src1;
  symref_t src2 = node->src2;

  if ( maybe_swap_source_operand(ctx, flags, REQUIRE_REG_SRC1, node, src1, ctx.t7) )
    node->src1 = ctx.t7;

  if ( maybe_swap_source_operand(ctx, flags, REQUIRE_REG_SRC2, node, src2, ctx.t8) )
    node->src2 = ctx.t8;

  if ( REQUIRES_SWAP(REQUIRE_REG_DEST, dest) )
  {
    symref_t olddest = node->dest;
    node->dest = ctx.t9;
    codenode_t *store = new codenode_t(CNT_SW, olddest, ctx.t9, NULLREF);
    codenode_t *oldnext = node->next;
    node->next = store;
    store->next = oldnext;
  }
}

//-----------------------------------------------------------------------------
static const char *cnt2instr(codenode_type_t type)
{
  switch ( type )
  {
    case CNT_ADD:  return "addu";
    case CNT_SUB:  return "sub";
    case CNT_DIV:  return "div";
    case CNT_MUL:  return "mul";
    case CNT_AND:  return "and";
    case CNT_OR:   return "or";
    case CNT_SLT:  return "slt";
    case CNT_SGT:  return "sgt";
    case CNT_SLE:  return "sle";
    case CNT_SEQ:  return "seq";
    case CNT_SNE:  return "sne";
    case CNT_SGE:  return "sge";
    case CNT_XOR:  return "xor";
    case CNT_SLLV: return "sllv";
    case CNT_SRLV: return "srlv";
    default:
      INTERR(1089);
  }
}

//-----------------------------------------------------------------------------
static uint32_t get_operand_desc(codenode_type_t type)
{
  switch ( type )
  {
    case CNT_LI:
    case CNT_LEA:
    case CNT_LB:
    case CNT_LW:
      return REQUIRE_REG_DEST;
    case CNT_MOV:
    case CNT_SB:
    case CNT_SW:
    case CNT_CNDJMP:
      return REQUIRE_REG_SRC1;
    case CNT_ADD:
    case CNT_SUB:
    case CNT_DIV:
    case CNT_MUL:
    case CNT_AND:
    case CNT_OR:
    case CNT_SLT:
    case CNT_SGT:
    case CNT_SLE:
    case CNT_SEQ:
    case CNT_SNE:
    case CNT_SGE:
    case CNT_SLLV:
    case CNT_SRLV:
      return REQUIRE_REG_DEST | REQUIRE_REG_SRC1 | REQUIRE_REG_SRC2;
    case CNT_SLL:
    case CNT_XOR:
    case CNT_NOT:
      return REQUIRE_REG_DEST | REQUIRE_REG_SRC1;
    default:
      break;
  }
  return 0;
}

//-----------------------------------------------------------------------------
static void gen_func_body(asm_ctx_t &ctx, codenode_t *code, symref_t epilogue)
{
  for ( code_iterator_t ci(code); *ci != NULL; ci++ )
  {
    codenode_t *node = *ci;

    ensure_compatible_operands(ctx, node, get_operand_desc(node->type));

    symref_t dest = node->dest;
    symref_t src1 = node->src1;
    symref_t src2 = node->src2;

    switch ( node->type )
    {
      case CNT_LI:
        {
          switch ( src1->type() )
          {
            case ST_INTCON:
              ctx.out(TAB1"li %s, %d\n", dest->loc.reg(), src1->val());
              break;
            case ST_CHARCON:
              ctx.out(TAB1"li %s, %s\n", dest->loc.reg(), src1->str());
              break;
            default:
              INTERR(1090);
          }
        }
        break;
      case CNT_MOV:
        {
          switch ( dest->loc.type() )
          {
            case SLT_GLOBAL:
              ctx.out(TAB1"sw %s, %s\n", src1->loc.reg(), dest->c_str());
              break;
            case SLT_STKOFF:
              ctx.out(TAB1"sw %s, %d($sp)\n", src1->loc.reg(), dest->loc.stkoff());
              break;
            case SLT_REG:
              ctx.out(TAB1"move %s, %s\n", dest->loc.reg(), src1->loc.reg());
              break;
            default:
              INTERR(1091);
          }
        }
        break;
      case CNT_LEA:
        {
          switch ( src1->loc.type() )
          {
            case SLT_GLOBAL:
              ctx.out(TAB1"la %s, %s\n", dest->loc.reg(), src1->c_str());
              break;
            case SLT_STKOFF:
              if ( src1->is_param() )
                ctx.out(TAB1"lw %s, %d($sp)\n", dest->loc.reg(), src1->loc.stkoff());
              else
                ctx.out(TAB1"la %s, %d($sp)\n", dest->loc.reg(), src1->loc.stkoff());
              break;
            case SLT_REG:
              ctx.out(TAB1"move %s, %s\n", dest->loc.reg(), src1->loc.reg());
              break;
            default:
              INTERR(1092);
          }
        }
        break;
      case CNT_SB:
      case CNT_SW:
        {
          const char *store = node->type == CNT_SB ? "sb" : "sw";

          switch ( dest->loc.type() )
          {
            case SLT_GLOBAL:
              ctx.out(TAB1"%s %s, %s\n", store, src1->loc.reg(), dest->c_str());
              break;
            case SLT_STKOFF:
              ctx.out(TAB1"%s %s, %d($sp)\n", store, src1->loc.reg(), dest->loc.stkoff());
              break;
            case SLT_REG:
              if ( dest->is_param() )
                ctx.out(TAB1"move %s, %s\n", dest->loc.reg(), src1->loc.reg());
              else
                ctx.out(TAB1"%s %s, (%s)\n", store, src1->loc.reg(), dest->loc.reg());
              break;
            default:
              INTERR(1093);
          }
        }
        break;
      case CNT_LB:
      case CNT_LW:
        {
          const char *load = node->type == CNT_LB ? "lb" : "lw";

          switch ( src1->loc.type() )
          {
            case SLT_GLOBAL:
              ctx.out(TAB1"%s %s, %s\n", load, dest->loc.reg(), src1->c_str());
              break;
            case SLT_STKOFF:
              ctx.out(TAB1"%s %s, %d($sp)\n", load, dest->loc.reg(), src1->loc.stkoff());
              break;
            case SLT_REG:
              if ( src1->is_param() )
                ctx.out(TAB1"move %s, %s\n", dest->loc.reg(), src1->loc.reg());
              else
                ctx.out(TAB1"%s %s, (%s)\n", load, dest->loc.reg(), src1->loc.reg());
              break;
            default:
              INTERR(1094);
          }
        }
        break;
      case CNT_ARG:
        {
          switch ( dest->loc.type() )
          {
            case SLT_REG:
              {
                switch ( src1->loc.type() )
                {
                  case SLT_STKOFF:
                    ctx.out(TAB1"lw %s, %d($sp)\n", dest->loc.reg(), src1->loc.stkoff());
                    break;
                  case SLT_REG:
                    ctx.out(TAB1"move %s, %s\n", dest->loc.reg(), src1->loc.reg());
                    break;
                  default:
                    INTERR(1095);
                }
              }
              break;
            case SLT_STKOFF:
              {
                switch ( src1->loc.type() )
                {
                  case SLT_STKOFF:
                    ensure_compatible_operands(ctx, node, REQUIRE_REG_SRC1);
                    src1 = node->src1;
                  case SLT_REG:
                    ctx.out(TAB1"sw %s, %d($sp)\n", src1->loc.reg(), dest->loc.stkoff());
                    break;
                  default:
                    INTERR(1096);
                }
              }
              break;
            default:
              INTERR(1097);
          }
        }
        break;
      case CNT_RET:
        {
          if ( dest != NULL )
          {
            switch ( src1->loc.type() )
            {
              case SLT_GLOBAL:
                ctx.out(TAB1"lw %s, %s\n", dest->loc.reg(), src1->c_str());
                break;
              case SLT_STKOFF:
                ctx.out(TAB1"lw %s, %d($sp)\n", dest->loc.reg(), src1->loc.stkoff());
                break;
              case SLT_REG:
                ctx.out(TAB1"move %s, %s\n", dest->loc.reg(), src1->loc.reg());
                break;
              default:
                INTERR(1098);
            }
          }

          ctx.out(TAB1"j %s\n", epilogue->c_str());
        }
        break;
      case CNT_SLL:
      case CNT_XOR:
        {
          const char *instr = node->type == CNT_SLL ? "sll" : "xor";

          switch ( src2->type() )
          {
            case ST_INTCON:
              ctx.out(TAB1"%s %s, %s, %d\n",
                      instr, dest->loc.reg(), src1->loc.reg(), src2->val());
              break;
            case ST_TEMP:
              ASSERT(0, node->type != CNT_SLL);
              ctx.out(TAB1"%s %s, %s, %s\n",
                      instr, dest->loc.reg(), src1->loc.reg(), src2->loc.reg());
              break;
            default:
              INTERR(0);
          }
        }
        break;
      case CNT_ADD:
      case CNT_SUB:
      case CNT_DIV:
      case CNT_MUL:
      case CNT_AND:
      case CNT_OR:
      case CNT_SLT:
      case CNT_SGT:
      case CNT_SLE:
      case CNT_SEQ:
      case CNT_SNE:
      case CNT_SGE:
      case CNT_SLLV:
      case CNT_SRLV:
        ctx.out(TAB1"%s %s, %s, %s\n",
                cnt2instr(node->type), dest->loc.reg(), src1->loc.reg(), src2->loc.reg());
        break;
      case CNT_CNDJMP:
        ctx.out(TAB1"beq %s, $zero, %s\n", src1->loc.reg(), dest->c_str());
        break;
      case CNT_NOT:
        ctx.out(TAB1"not %s, %s\n", dest->loc.reg(), src1->loc.reg());
        break;
      case CNT_CALL:
        ctx.out(TAB1"jal %s\n", node->src1->c_str());
        break;
      case CNT_LABEL:
        ctx.out("%s:\n", node->src1->c_str());
        break;
      case CNT_JUMP:
        ctx.out(TAB1"j %s\n", node->dest->c_str());
        break;
      default:
        continue;
    }
  }
}

//-----------------------------------------------------------------------------
static void gen_builtin_function(asm_ctx_t &ctx, const char *name, int syscall)
{
  ctx.out("\n%s:\n"
          TAB1"li $v0, %d\n"
          TAB1"syscall\n"
          TAB1"jr $ra\n", name, syscall);
}

//-----------------------------------------------------------------------------
static void set_register_names(ir_func_t &f)
{
  // temps
  symvec_t temps;
  f.get_used_resources(ST_TEMP, temps);

  for ( symvec_t::iterator i = temps.begin(); i != temps.end(); i++ )
  {
    symbol_t &temp = **i;
    temp.loc.set_reg(tempreg_names[temp.val()]);
  }

  // $v0
  symref_t retval = f.gen_resource(ST_RETVAL);
  retval->loc.set_reg("$v0");

  // $zero
  symref_t zero = f.gen_resource(ST_ZERO);
  zero->loc.set_reg("$zero");
}

//-----------------------------------------------------------------------------
static void gen_text_section(asm_ctx_t &ctx, ir_funcs_t &funcs)
{
  ctx.out(".text\n");

  for ( ir_funcs_t::iterator i = funcs.begin(); i != funcs.end(); i++ )
  {
    ir_func_t &f = **i;
    set_register_names(f);

    ctx.out("\n%s:\n", f.sym->c_str());

    stack_frame_t frame(f, ctx);
    frame.print();

    frame.gen_prologue();
    gen_func_body(ctx, f.code, frame.epilogue_lbl);
    frame.gen_epilogue();
  }

  gen_builtin_function(ctx, "_"BI_PRINT_STRING, 4);
  gen_builtin_function(ctx, "_"BI_PRINT_INT,    1);
  gen_builtin_function(ctx, "_"BI_PRINT_CHAR,  11);
  gen_builtin_function(ctx, "_"BI_PRINT_HEX,   34);
  gen_builtin_function(ctx, EXIT, 10);
}

//-----------------------------------------------------------------------------
#define FMTLEN  1024
#define NAMELEN 32
#define OFFLEN  64

static const char *sep =
"|--------------------------------|";

//-----------------------------------------------------------------------------
static void print_frame_item(stack_frame_t &frame, offset_t off, const char *fmt, ...)
{
  char namestr[FMTLEN];

  va_list va;
  va_start(va, fmt);
  vsnprintf(namestr, FMTLEN, fmt, va);
  va_end(va);

  char item[TABLEN+NAMELEN+5]; // <tab> + '#' + ' ' + '|' + name + '|' + '\0'
  char *ptr = item;
  const char *const end = item + sizeof(item);

  const char *pfx = TAB1"# |";
  APPSTR(ptr, end, pfx, strlen(pfx));

  int len = cmin(strlen(namestr), NAMELEN);
  const char *const name_end = ptr + NAMELEN;

  APPCHAR(ptr, end, ' ', (NAMELEN - len) / 2);
  APPSTR (ptr, end, namestr, len);
  APPCHAR(ptr, end, ' ', name_end-ptr);
  APPCHAR(ptr, end, '|', 1);
  APPZERO(ptr, end);

  frame.ctx.out("%s\n", item);

  char offstr[OFFLEN];
  snprintf(offstr, OFFLEN,
           "sp+%d%s",
           off, off == frame.size() ? "  <-- start of caller's stack" : "");

  frame.ctx.out(TAB1"# %s %s\n", sep, offstr);
}

//-----------------------------------------------------------------------------
void stack_frame_t::print_pseudo_section(int sectionid, const char *label)
{
  if ( sections[sectionid].is_valid() )
    print_frame_item(*this, sections[sectionid].start, label);
}

//-----------------------------------------------------------------------------
void stack_frame_t::print()
{
  ctx.out("\n"TAB1"# %s\n", sep);

  // PARAMS -------------------------------------------------------------------
  struct param_printer_t : public frame_item_visitor_t
  {
    virtual void visit_item(item_info_t &info) // TODO: const?
    {
      symbol_t &param = info.sym;

      if ( param.loc.is_stkoff() )
        print_frame_item(info.frame, param.loc.stkoff(), param.c_str());
      else
        print_frame_item(info.frame, info.sec.start + info.idx * WORDSIZE,
                         "<%s is in %s>",
                         param.c_str(), param.loc.reg());
    }
  } pp;

  visit_items(FS_PARAMS, pp, FIV_REVERSE);

  // PADDING2 -----------------------------------------------------------------
  print_pseudo_section(FS_PADDING2, "<padding>");

  // LVARS --------------------------------------------------------------------
  struct lvar_printer_t : public frame_item_visitor_t
  {
    virtual void visit_item(item_info_t &info)
    {
      symbol_t &lvar = info.sym;

      if ( !lvar.is_param() )
        print_frame_item(info.frame, lvar.loc.stkoff(), lvar.c_str());
    }
  } lvp;

  visit_items(FS_LVARS, lvp, FIV_REVERSE);

  // PADDING1 -----------------------------------------------------------------
  print_pseudo_section(FS_PADDING1, "<padding>");

  // RA -----------------------------------------------------------------------
  struct ra_printer_t : public frame_item_visitor_t
  {
    virtual void visit_item(item_info_t &info)
    {
      print_frame_item(info.frame, info.sec.start, info.sym.loc.reg());
    }
  } rap;

  visit_items(FS_RA, rap, FIV_REVERSE);

  // STKTEMPS -----------------------------------------------------------------
  struct stktemp_printer_t : public frame_item_visitor_t
  {
    virtual void visit_item(item_info_t &info)
    {
      print_frame_item(info.frame,
                       info.sym.loc.stkoff(),
                       "<stktemp %d>", info.sym.val());
    }
  } stp;

  visit_items(FS_STKTEMPS, stp, FIV_REVERSE);

  // SVREGS -------------------------------------------------------------------
  struct svregs_printer_t : public frame_item_visitor_t
  {
    virtual void visit_item(item_info_t &info)
    {
      print_frame_item(info.frame,
                       info.sec.start + info.idx * WORDSIZE,
                       info.sym.loc.reg());
    }
  } srp;

  visit_items(FS_SVREGS, srp, FIV_REVERSE);

  // STKARGS ------------------------------------------------------------------
  struct stkargs_printer_t : public frame_item_visitor_t
  {
    virtual void visit_item(item_info_t &info)
    {
      print_frame_item(info.frame,
                       info.sym.loc.stkoff(),
                       "<stkarg %d>", info.sym.val());
    }
  } sag;

  visit_items(FS_STKARGS, sag, FIV_REVERSE);

  // REGARGS ------------------------------------------------------------------
  print_pseudo_section(FS_REGARGS, "<minimum 4 arg slots>");
}

//-----------------------------------------------------------------------------
void generate_mips_asm(asm_ctx_t &ctx, ir_t &ir)
{
  init_gsyms(ctx, ir);
  gen_data_section(ctx);
  gen_text_section(ctx, ir.funcs);
}
